---
title: "Mastering Binary Search Algorithm"
description: "A comprehensive guide to understanding and implementing binary search with practical examples and common variations."
publishedAt: "2024-01-15"
updatedAt: "2024-01-20"
author: "Tech Interview Expert"
tags: ["algorithms", "binary-search", "interview-prep", "data-structures"]
category: "algorithms"
featured: true
difficulty: "intermediate"
readingTime: 8
---

# Mastering Binary Search Algorithm

Binary search is one of the most fundamental algorithms every software engineer should master. It's efficient, elegant, and appears frequently in technical interviews.

## What is Binary Search?

Binary search is a **divide-and-conquer** algorithm that finds the position of a target value within a sorted array. It compares the target value to the middle element of the array.

### Time Complexity
- **Best Case**: O(1) - target is the middle element
- **Average Case**: O(log n)
- **Worst Case**: O(log n)

### Space Complexity
- **Iterative**: O(1)
- **Recursive**: O(log n) due to call stack

## Basic Implementation

Here's the classic iterative implementation:

```python
def binary_search(arr, target):
    left, right = 0, len(arr) - 1
    
    while left <= right:
        mid = left + (right - left) // 2
        
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    
    return -1  # Target not found
```

### Key Points:
- Use `left + (right - left) // 2` to avoid integer overflow
- The loop condition is `left <= right`
- Update pointers correctly: `left = mid + 1` or `right = mid - 1`

## Common Variations

### 1. Find First Occurrence
```python
def find_first(arr, target):
    left, right = 0, len(arr) - 1
    result = -1
    
    while left <= right:
        mid = left + (right - left) // 2
        
        if arr[mid] == target:
            result = mid
            right = mid - 1  # Continue searching left
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    
    return result
```

### 2. Find Last Occurrence
```python
def find_last(arr, target):
    left, right = 0, len(arr) - 1
    result = -1
    
    while left <= right:
        mid = left + (right - left) // 2
        
        if arr[mid] == target:
            result = mid
            left = mid + 1  # Continue searching right
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    
    return result
```

## Practice Problems

> Try these problems to master binary search:
> 
> 1. **Search Insert Position** (LeetCode 35)
> 2. **Find Peak Element** (LeetCode 162)
> 3. **Search in Rotated Sorted Array** (LeetCode 33)

## Interview Tips

1. **Clarify the problem**: Is the array sorted? Are there duplicates?
2. **Choose the right template**: Basic search vs. boundary search
3. **Handle edge cases**: Empty array, single element, target not found
4. **Test with examples**: Walk through your solution step by step

Binary search is not just about finding elementsâ€”it's a powerful technique for **optimization problems** and **decision problems** where you can eliminate half the search space at each step.

---

*Next up: Learn about [Two Pointers Technique](/posts/two-pointers-technique) and how it complements binary search in problem-solving.*